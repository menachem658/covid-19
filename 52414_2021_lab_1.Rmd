---
date: "27/4/2021"
output: html_document
---

# Basic Data Wrangling and Plotting*  

<br/><br/>
```{r, include=FALSE}
library(tidyverse) # This includes dplyr, stringr, ggplot2, .. 
library(data.table)
```  
<br/><br/>

## Analysis of the World Covid-19 Dataset         
    
The `world-of-data` website hosts world-wide epidemiological data on the Corona Virus (COVID-19). 
The dataset is compiled by the Johns Hopkins University Center for Systems Science and Engineering (JHU CCSE) from various sources, 
and follows The dataset contains data since January 2020. For the data and more information about it, please visit [here](https://github.com/owid/covid-19-data/tree/master/public/data).    <br>
  
You can see several nice visualizations of the data [here](https://ourworldindata.org/covid-vaccinations)
  
In this lab we will focus on analyzing the Covid-19 cases, deaths and vaccinations data over time for different countries.   



loading the complete covid19 dataset in csv format from the world-of-data and changing the class to date
```{r}
df <- read.csv(url("https://covid.ourworldindata.org/data/owid-covid-data.csv"))
df$date = as.Date(df$date) # change Date from factor to date type
class(df$date)
```  
cleaning the data from rows with “world” and “international” values
```{r}
df = filter(df, location!="World" & location!= "International" & location!= "European Union")
```


Create a function that will use me on finding a maximum for three different columns.

First a sort is performed by a function aggregate.
For sub-arrays by country, then relatively manually the date is given to give the array by a function which. The function will be activated three times, once for each column requested in time. Later on for each function the column name was also updated.
```{r}
top_5 <- function(x){
  cases.agg <- aggregate(df[,as.numeric(x)]~location ,df, FUN = max)
  total.x.per.million.top <- head(cases.agg[order(cases.agg[2],decreasing = TRUE),],5) # Ordering by Value, desc
  last_date <- data.frame(location=NA, date = NA, total=NA)
  for (i in 1:nrow(total.x.per.million.top)){
    total_top <- total.x.per.million.top[i,2]
    ind <- which(total_top == df[,as.numeric(x)])
    y <- head(df[ind,][order(df[ind,]$date,decreasing = TRUE),],1)
    last_date <-rbind(last_date,data.frame(location = y$location,date = as.character.Date(y$date),total = y[,as.numeric(x)]))}
  last_date <- na.omit(last_date)
  last_date$date = as.Date(last_date$date)
  return(last_date)}
```
The top 5 of `total_cases_per_million`.
```{r}
top.5 <- top_5(which( colnames(df)=="total_cases_per_million"))
names(top.5)[names(top.5) == "total"] <- "total_cases_per_million"
rownames(top.5)<-NULL
print(top.5)
```
The top 5 of `total_deaths_per_million`.
```{r}
top.5 <- top_5(which( colnames(df)=="total_deaths_per_million"))
names(top.5)[names(top.5) == "total"] <- "total_deaths_per_million"
rownames(top.5)<-NULL
print(top.5)
```
Top 5 of `total_vaccinations_per_hundred`.
```{r}
top.5 <- top_5(which( colnames(df)=="total_vaccinations_per_hundred"))
names(top.5)[names(top.5) == "total"] <- "total_vaccinations_per_million"
rownames(top.5)<-NULL
print(top.5)
```

 Writing a function that recieves as input the data-frame, and a column name as string. The function plots the value of the input column as a function of the date for each of the six continents.

we filtered the data by rows, and created a smaller dataset with data for every continent. 
We used the ggplot basic function, in order to create a scatter plot of the input column by dates, and used a different color for each line to tell apart every continent.
```{r}
myfun = function(dat_frame,name){
  data_frame2<-dat_frame %>% drop_na(all_of(name)) %>% filter(continent=="")
  ggplot(data_frame2,aes_string(y=name,col="location"))+ geom_line(aes(x=as.Date(date)))+ylab(gsub("_"," ",name))+xlab("date")+theme_bw()}
```

Using the function written in a. and plot of the number of `new_cases` for the continents. making a similar plot for the *log* of the *smoothed* number of new cases. 
Note that mathematically it isn't possible to calculate log function with not positive values, so we used the log function only on the positive data.
```{r}

myfun(df, "new_cases")

df$new_cases_smoothed_log=log(df$new_cases_smoothed)
myfun(df, "new_cases_smoothed_log")

df$new_deaths_smoothed_log=log(df$new_deaths_smoothed)
myfun(df, "new_deaths_smoothed_log")

df$new_vaccinations_smoothed_log=log(df$new_vaccinations_smoothed)
myfun(df, "new_vaccinations_smoothed_log")
```
Obviously it is much easier to interpret the smoothed data graph than the not-smoothed, because the log function makes the data clearer and normalized, and the smoothed function on the data values makes it more informative as it become more continuous, so you can see clearly the trend for each continent.

4a.  Writing a function that recieves as input the data-frame and a column to complete, and computes for each continent the corresponding values. 

At first, we filtered the dataframe so it'll include only country level data. Then we created a vector of the continents, and for each continent we created subdataframe with rows corresponded with the current continent.
We turned the Na values to 0 so they won't influence the results.
Finally we aggregated the sum of values of the input column by date, and joined all the subdataframes for each continent into one dataframe. 
```{r}
myfun2 = function(dat_frame2,name2){
  data_frame2<-dat_frame2%>%filter((continent!="") & (location != "World"))
  continents=c("Africa","Asia","Europe","North America","Oceania","South America")
  contidata=data.frame()
  contitemp=data.frame()
  for(i in c(continents)){
    contitemp= filter(data_frame2, continent== all_of(i))
    sub=contitemp[c("date",all_of(name2))]
    sub[is.na(sub)]=0
    colnames(sub)=c("date","x")
    aggtemp=aggregate(sub$x, by=list(sub$date), sum)
    aggtemp$continent=i
    contidata=rbind(contidata,aggtemp)}
colnames(contidata)=c("date",all_of(name2),"continent")
return(contidata)}
```

Applying the function from a. to fill the `new_tests_smoothed` column for the continents, and plotting the *log* of the *smoothed* number per continent vs. date using the function from qu. 3. 
```{r}
datab =myfun2(df,"new_tests_smoothed")
datab=filter(datab,new_tests_smoothed>0)
datab$log_new_tests_smoothed=log(datab$new_tests_smoothed)
datab$location=datab$continent
datab$continent=""
myfun(datab,"log_new_tests_smoothed")
```
Note that when applying both functions on our dataframe and the new_tests_smoothed column, we get a vericle line in the ggplot on the last few dates (this is the reason we omitted the last day from the plot, to minimize this anomaly). This happened because the number of new tests decreased drastically in the last couple of days with the big dicline in corona cases.

  Creating a new data-frame with one row per country, that for each countrie will store as columns the current `total_cases_per_million` and `total_deaths_per_million`, in addition to the country name (`location`), and creating a scatter plot on this data.

The data frame
```{r}
dat1 <- aggregate(total_deaths_per_million~location,df,FUN = max)
dat2 <- aggregate(total_cases_per_million~location,df,FUN = max)
sub.data.7 <- full_join(dat1,dat2,by = "location")
```
The scatter plot
```{r}
cleandat = na.omit(sub.data.7)
options(scipen = 100)
plot(cleandat$total_cases_per_million, cleandat$total_deaths_per_million, main="number of deaths per million as a function of the number of cases per million",
   xlab="total cases per million ", ylab="total deaths per million ", pch=19)
abline(lm(cleandat$total_deaths_per_million~cleandat$total_cases_per_million), col="red")
reg=lm(cleandat$total_deaths_per_million~cleandat$total_cases_per_million)
summary(reg)
```
From The plot we can conclude that there is a positive correlation between the total cases per million and the total deaths per million for an arbitrary country.
The slope is equal to `r round(coef(reg)[2],3)`, which means that for every case of the virus, there will be `r round(coef(reg)[2],3)` death. In other words, for every 1000 cases, there will be approximately `r round(coef(reg)[2]*1000,3)` death cases.
Note that the intercept we got from the regression summary is around `r round(coef(reg)[1],3)`, which doesn't seem possible, as it represents the number of total deaths per million for zero total cases per million.

 Finding for each country the date at which the number of new `cases` was maximal, and the date at which the number of new `deaths` was maximal, and creating a scatter plot.
```{r}
max.cases <-  df %>% filter(!(continent == '') & !is.na(new_cases)) %>% select(location, date, new_cases) %>% group_by(location) %>% top_n(1,new_cases ) %>% top_n(1,date)  
names(max.cases)[names(max.cases) == "date"] <- "date_of_max_cases"
max.deaths <-  df %>% filter(!(continent == '') & !is.na(new_deaths)) %>% select(location, date, new_deaths) %>% group_by(location) %>% top_n(1,new_deaths) %>% top_n(1,date) 
names(max.deaths)[names(max.deaths) == "date"] <- "date_of_max_deaths"
sub.data.7 <-  full_join(sub.data.7,max.cases,by = "location")
sub.data.7 <- na.omit(sub.data.7)
sub.data.7 <-  full_join(sub.data.7,max.deaths,by = "location")
sub.data.7=select(sub.data.7, c(location,total_deaths_per_million,total_cases_per_million,date_of_max_cases,new_cases,date_of_max_deaths,new_deaths))
```
a linear regression
```{r}
reg <- lm(as.matrix(date_of_max_deaths)~as.matrix(date_of_max_cases),data=sub.data.7)
summary(reg)
```
a scatter plot with a linear regression line
```{r}
options(scipen = 100)
ggplot(data = sub.data.7, mapping = aes(x = date_of_max_cases, y = date_of_max_deaths))+geom_point()+geom_smooth(method="lm", se=F)+ylab(gsub("_"," ","date_of_max_deaths"))+xlab(gsub("_"," ","date_of_max_cases"))
```

The slop of the graph represents the relation between the dates of max new deaths and the dates of max new cases. If more dates of max new deaths are equal to the dates of max new cases for each country respectively, then the slope will be closer to 1, and according to the regression summary it is equal to `r round(coef(reg)[2],3)`
According to the scatter plot it doesn't seem like the slope is close to 1, in addition the variance of our observations is quite big,however it still looks like there is a positive linear connection between the dates.
The x-axis represents the dates of max new cases for each country, so in our opinion the intercept represents the date of max new deaths for the first country in our data frame.The intercept in our regression is equal to  `r round(coef(reg)[1], 3)` , which is not very informative because the y axis represents dates, and not numbers, whereas the regression interprets the given dates as numeric. 

computing the world-wide number of `new_cases`, `new_deaths` and `new_vaccinations` by month. 
note that we have to aggregate all of the three columns using sum function, bacause those values are total values.

We changed the NA values to 0, because all of the NA data about the new vaccinations means that there were no vaccinations yet, so the bar plot created for the new vaccinations data is correct and logical.

The monthly dataframe
```{r}
temp=data.frame(c(df$location),c(df$date),c(df$new_cases),c(df$new_deaths),c(df$new_vaccinations))
temp[is.na(temp)] <- 0
temp$c.df.new_cases.=as.numeric(temp$c.df.new_cases.)
temp$c.df.new_deaths.=as.numeric(temp$c.df.new_deaths.)
temp$c.df.new_vaccinations.=as.numeric(temp$c.df.new_vaccinations.)
short.date = strftime(temp$c.df.date., "%Y-%m")
aggr.stat1 = aggregate(temp$c.df.new_cases.~ short.date, FUN = sum)
aggr.stat2 = aggregate(temp$c.df.new_deaths.~ short.date, FUN = sum)
aggr.stat3 = aggregate(temp$c.df.new_vaccinations.~ short.date, FUN = sum)
monthly=data.frame(c(aggr.stat1),c(aggr.stat2[,2]),c(aggr.stat3[,2]))
colnames(monthly)=c("months","new_cases","new_deaths","new_vaccinations")
```
The barplots
```{r}
# Fitting Labels
par(las=2) # make label text perpendicular to axis
par(mar=c(4,8,4,2)) # increase y-axis margin.
monthly.cases.plot <- barplot(monthly$new_cases, main = "new cases", xlab = "months", ylab = "number of cases",
        col = '#E94A4A', border="white", space=0.04, font.axis=2, 
        names.arg = c(as.character(monthly$months)), cex.axis = 0.55, cex.names = 0.55,las=2)

# Add text of the number of cases and a legend 
text(x=monthly.cases.plot,y=c(monthly$new_cases),label=c(monthly$new_cases), pos=3,cex=0.5, col="black")

```

```{r}
monthly.deaths.plot <- barplot(monthly$new_deaths, main = "new deaths", xlab = "months", ylab = "number of cases",
        col = '#F59158', border="white", space=0.04, font.axis=2, 
        names.arg = c(as.character(monthly$months)), cex.axis = 0.55, cex.names = 0.55,las=2)

# Add text of the number of cases and a legend 
text(x=monthly.cases.plot,y=c(monthly$new_deaths),label=c(monthly$new_deaths), pos=3, cex=0.5, col="black")
```

```{r}
monthly.vaccinations.plot <- barplot(monthly$new_vaccinations, main = "new vaccinations", xlab = "months", ylab = "number of cases",
        col = '#F5c138', border="white", space=0.04, font.axis=2, 
        names.arg = c(as.character(monthly$months)), cex.axis = 0.55, cex.names = 0.55,las=2)

# Add text of the number of cases and a legend 
text(x=monthly.cases.plot,y=c(monthly$new_vaccinations),label=c(monthly$new_vaccinations), pos=3,cex=0.5, col="black")
```

7. making a histogram of the current death rates over all countries with 50 bins

creating the death rate
```{r}
df <- mutate(df, death_rate = total_deaths / total_cases)
data <- df %>% drop_na(death_rate) %>% select(location, death_rate, date) %>% group_by(location) %>% top_n(1, date)
```
creating the histogram
```{r}
hist(data$death_rate, breaks=50, main="death rate frequency",xlab = "death rate",col='#65BDED', border="white", font.axis=2)
```
Top 3 countries with highest death rate
```{r}
top_3 <- head(data[order(data[2],decreasing = TRUE),],3) # Ordering by Value
rownames(top_3) <-NULL
top_3[1:2]
```

investigating whether different countries employ different vaccination strategies

Create a new column as required by a function mutate.
```{r}
df <-mutate(df, two_dose_fraction = people_fully_vaccinated / people_vaccinated)
```
Creating a sub-array in which only the countries of education are included.
```{r}
sub_data <- df %>% select(location, date, two_dose_fraction) %>% na.omit() %>% subset( location == "Israel" |location =='United Kingdom'|location =='United States')
```
Create a scatter plot for those countries.
```{r}
ggplot(sub_data,aes_string(y='two_dose_fraction', col="location"),main="Rate of two vaccine doses by date")+ geom_line(aes(x=as.Date(date)), size=1)+ylab('two dose fraction')+xlab(NULL)+theme_bw()
```


It can be seen that Israel used the two-dose vaccine method, as did the United States, only that in Israel there was pressure and strong publicity for vaccines. In the UK they started with two doses and then switched to one dose for a while and thought it was more effective after a while they switched again to two doses of vaccine (probably was not so effective). And what explains the sharp rise is that there are an amount of people who have been vaccinated once, now only the second vaccine remains.

studying the time delay between the diagnosis of Covid-19 and the death from Covid-19 for cases not surviving the disease.

a. creating function that recieves as input the data-frame, a country name and the name of two columns, and computes the value of their cross-correlation in this country for time delay of up to two months apart, that is for all values of $\Delta_t$ between $-60$ days and $60$ days. 
```{r}
cross_correlation <- function(data_frame,country,column1,column2){
  required.location <- filter(data_frame,location == country)
  X <- required.location[[column1]]
  Y <- required.location[[column2]]
  min_date <- min(required.location$date)
  max_date <- max(required.location$date)
  negative <- seq(60,0,-1)
  Positive <- seq(1:60)
  cross_correlation=c()
  for (i in negative){
    delta_t_y <- seq(min_date,max_date-i,by="days")
    delta_t_x <- seq(min_date+i,max_date,by="days")
    y_t <- required.location %>% filter(date %in% delta_t_y) %>% select(column2)
    x_t <- required.location %>% filter(date %in% delta_t_x) %>% select(column1)
    cross_correlation=c(cross_correlation, cor(y_t, x_t,use="complete.obs"))}
  for (i in Positive){
    delta_t_x <- seq(min_date, max_date-i, by="days")
    delta_t_y <- seq(min_date+i, max_date, by="days")
    x_t <- required.location %>% filter(date %in% delta_t_x) %>% select(column1)
    y_t <- required.location %>% filter(date %in% delta_t_y) %>% select(column2)
    cross_correlation = c(cross_correlation, cor(x_t,y_t, use="complete.obs"))}
  return(cross_correlation)}
```

b. Computing the cross correlation between the number of  `new_cases` and `new_deaths` for *Canada*, and plot it as a function of $\Delta_t$.

running the function.
```{r}
candada.cross.correlation <- cross_correlation(df,"Canada","new_cases","new_deaths")
time_delay <- seq(-60,60,1)
p <- plot(time_delay, candada.cross.correlation, main= 'cross correlation between the new cases and new deaths for Canada', cex=.9, col='#0078FF', xlab='time delay', ylab='cross correlation of candada.')
par(new=TRUE)
time_delay[which.max(candada.cross.correlation)]
```
We can see according to the graph that the peak appears around the `r time_delay[which.max(candada.cross.correlation)]` day.
The meaning of this fact, is that if someone gets infected by the virus on a specific date, then he would likely die approximately `r time_delay[which.max(candada.cross.correlation)]` days afterwards in canada.
In other words, the peak in the graph represents the approximated number of days between the infection day and the death day for the same person.


examining if the data shows evidence for the effectiveness of the vaccines in reducing the number of Covid-19 cases. 
```{r}
maximal.cases <-  aggregate(new_cases_smoothed~location,df,FUN = max) # In order for me to get the maximum as required.
current.cases <- df %>% filter(date == '2021-04-23') %>% select(location,new_cases_smoothed) # In order for me to get the data according to the mine date.
vaccinations.cases <- df %>% filter(date == '2021-04-1') %>% select(location,total_vaccinations_per_hundred) # In order for me to get the data according to the mine date.
colnames(maximal.cases)[colnames(maximal.cases) == 'new_cases_smoothed'] <- 'maximal_cases_smoothed' # Update a column name.
colnames(current.cases)[colnames(current.cases) == 'new_cases_smoothed'] <- 'current_cases_smoothed' # Update a column name.
#Consolidation of columns in order to get as required.
sub.data <- full_join(current.cases,maximal.cases,by = "location")
sub.data <- mutate(sub.data, ratio_between_current_maximal = current_cases_smoothed/maximal_cases_smoothed)
sub.data <- full_join(sub.data,vaccinations.cases,by = "location")
```
In order for me to highlight those countries as required.
```{r}
outliers <- sub.data %>%  subset( location == "Israel" |location =='United Kingdom')
```
Create a scatter plot for those countries with outlines Israel and United Kingdom
```{r}
with(sub.data, plot(y=total_vaccinations_per_hundred, x=log(ratio_between_current_maximal), main='comparing the vaccination rate and the ratio rate', cex=.9, col='#0078FF', ylab='total vaccinations per hundred', xlab='log ratio between current dna maximal rate'))
par(new=TRUE)
with(outliers, points(log(ratio_between_current_maximal), total_vaccinations_per_hundred, cex=.9, col='red'))
with(outliers, text(total_vaccinations_per_hundred~log(ratio_between_current_maximal), labels=location, cex=0.7, pos=2, col='red'))
```
We expect there to be a high correlation between the ratio and the amount of strains. The greater the amount of vaccines, the lower the ratio.
We see that the countries of Israel and the United Kingdom that used the two-dose vaccine as can be seen in question 8,
then the rate of decrease in the ratio is significant.
There are countries whose vaccination rate is low and at the same time the rate is also low, 
this can be explained by other reduction methods such as curfews (but which have really moved and not like in Israel).
There are countries where the vaccination rate is large but the decrease is relatively low. This can be attributed to the use of one dose or of vaccines by other companies, in which the percentage of vaccination is lower than in companies used in Israel and England.








